import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;
import java.util.*;
import java.io.*;
import java.math.*;


class Entity {
    public int id;
    public int type; // 0=monster, 1=your hero, 2=opponent hero
    public int x; // Position of this entity
    public int y;
    public int shieldLife; // Ignore for this league; Count down until shield spell fades
    public int isControlled; // Ignore for this league; Equals 1 when this entity is under a control spell
    public int health; // Remaining health of this monster
    public int vx; // Trajectory of this monster
    public int vy;
    public int nearBase; // 0=monster with no target yet, 1=monster targeting a base
    public int threatFor; // Given this monster's trajectory, is it a threat to 1=your base, 2=your opponent's base, 0=neither
    public int lastSeenTurn;
    public boolean isTargeted = false;

    public Entity(int id) {
        this.id = id;
    }

    public boolean isMonster() {
        return type == 0;
    }

    public boolean isMyHero() {
        return type == 1;
    }

    public boolean isOpponentHero() {
        return type == 2;
    }


    public boolean isAlive(int currentTurn) {
        return lastSeenTurn == currentTurn;
    }

    public boolean isGoingToBase() {
        return nearBase == 1 && threatFor == 1;
    }

    public double getSpeed() {
        return 800;
    }

    public Point2D getPosition() {
        return new Point2D(x, y);
    }

    public Point2D getSpeedVector() {
        return new Point2D(vx, vy);
    }

    public boolean isBaseThreat(GameMap map) {
        double a = vy/vx;
        double b = y - a * x;
        if (map.baseX == 0) {
            double y0 = b;
            double x0 = -b / a;
            return (y0 > 0 && y0 < 5000) || (x0 > 0 && x0 < 5000);
        } else {
            double yMax = a * map.baseX + b;
            double xMax = (map.baseY - b) / a;
            return (map.baseX - xMax > 0 && map.baseX - xMax <  5000) || (map.baseY - yMax > 0 && map.baseY - yMax <  5000);
        }
    }

    @Override
    public String toString() {
        return "Entity[type=" + type + ",x=" + x + ",y=" + y + ",vx=" + vx + ",vy" + vy + "]";
    }
}


class Hero {
    public Entity entity;
    public Entity target;
    public Point2D targetPoint;
    public Point2D patrolPoint;
    public Strategy strategy;
    public Hero(Entity entity) {
        this.entity = entity;
    }

}


class GameMap {
    int maxX=17630;
    int maxY=9000; 

    // The corner of the map representing your base
    public int baseX;
    public int baseY;
    public Point2D patrolPoint1;
    public Point2D patrolPoint2;

    public GameMap(int x, int y) {
        this.baseX = x;
        this.baseY = y;
        if (baseX == 0) {
            patrolPoint1 = new Point2D(2000, 6000);
        } else {
            patrolPoint1 = new Point2D(baseX - 2000 , baseY - 6000);
        }
        if (baseX == 0) {
            patrolPoint2 = new Point2D(6000, 2000);
        } else {
            patrolPoint2 = new Point2D(baseX - 6000 , baseY - 2000);
        }
    }

    @Override
    public String toString() {
        return "GameMap[baseX=" + baseX + ", baseY=" + baseY + "]";
    }   
}

class GamePlayer {
    public int health;  // Each player's base health
    public int mana; // Ignore in the first league; Spend ten mana to cast a spell
}



class GameState {

    public GameMap map;
    public int heroesPerPlayer; // Always 3
    public GamePlayer me;
    public GamePlayer opponent;
    public Map<Integer, Entity> entityMap = new HashMap<>();
    public Hero[] myHeroes = new Hero[3];
    public int turn = 0;


    public void initState(Scanner in) {
        map = new GameMap(in.nextInt(),in.nextInt());   
        heroesPerPlayer = in.nextInt();
        me = new GamePlayer();
        opponent = new GamePlayer();
    }

    public void newTurn(Scanner in) {
        turn++;
        // players data
        me.health = in.nextInt();
        me.mana = in.nextInt(); 
        opponent.health = in.nextInt();
        opponent.mana = in.nextInt();

        int entityCount = in.nextInt(); // Amount of heros and monsters you can see
        int myHeroesIndex = 0;
        for (int i = 0; i < entityCount; i++) {
            int id = in.nextInt(); // Unique identifier
            if (!entityMap.containsKey(id)) {
                entityMap.put(id, new Entity(id));
            }
            Entity currentEntity = entityMap.get(id);
            currentEntity.type = in.nextInt(); // 0=monster, 1=your hero, 2=opponent hero
            currentEntity.x = in.nextInt(); // Position of this entity
            currentEntity.y = in.nextInt();
            currentEntity.shieldLife = in.nextInt(); // Ignore for this league; Count down until shield spell fades
            currentEntity.isControlled = in.nextInt(); // Ignore for this league; Equals 1 when this entity is under a control spell
            currentEntity.health = in.nextInt(); // Remaining health of this monster
            currentEntity.vx = in.nextInt(); // Trajectory of this monster
            currentEntity.vy = in.nextInt();
            currentEntity.nearBase = in.nextInt(); // 0=monster with no target yet, 1=monster targeting a base
            currentEntity.threatFor = in.nextInt(); // Given this monster's trajectory, is it a threat to 1=your base, 2=your opponent's base, 0=neither
            currentEntity.lastSeenTurn = turn;
            if (currentEntity.isMyHero()) {
                if (myHeroes[myHeroesIndex] == null) {
                    myHeroes[myHeroesIndex++] = new Hero(currentEntity);
                }
            }
        }


    }
    
}




/**
 * Auto-generated code below aims at helping you parse
 * the standard input according to the problem statement.
 **/
class Player {


    public static void main(String args[]) {
        Scanner in = new Scanner(System.in);

        // Initialization of game state
        long initStart = System.currentTimeMillis();
        
        GameState gameState = new GameState();
        gameState.initState(in);

        long initEnd = System.currentTimeMillis();
        System.err.println("Initialization duration: " + (initEnd-initStart));
        // game loop
        while (true) {
            long start = System.currentTimeMillis();
            gameState.newTurn(in);
           
            for (int i = 0; i < gameState.heroesPerPlayer; i++) {
                double selectedDistance = 999999999;
                Entity selectedMonster = null;
                Point2D selectedInterceptionPoint = null;
                double selectedDistanceBaseThreat = 999999999;
                Entity selectedMonsterBaseThreat = null;
                Point2D selectedInterceptionPointBaseThreat = null;
                Hero currentHero = gameState.myHeroes[i];
                
                    System.err.println(currentHero);
                // hastarget
                if (currentHero.target != null
                && currentHero.target.isAlive(gameState.turn)
                && Utils.distance(currentHero.entity, currentHero.target) < 1600) {

                    currentHero.targetPoint = Utils.calculateInterceptionPoint(currentHero.entity, currentHero.target);


                } else {
                    if (currentHero.target != null) {
                        currentHero.target.isTargeted = false;
                        currentHero.target = null;
                    }
                    for (Entity target : gameState.entityMap.values()) {
                        if (target.isMonster() && target.isAlive(gameState.turn) && !target.isTargeted) {
                            System.err.println(target);
                            Point2D interceptionPoint = Utils.calculateInterceptionPoint(currentHero.entity, target);
                            System.err.println(interceptionPoint);

                            double currDist = Utils.distance(currentHero.entity.getPosition(), interceptionPoint);
                            if (currDist < selectedDistance ) {
                                selectedDistance = currDist;
                                selectedMonster = target;
                                selectedInterceptionPoint = interceptionPoint;
                            }
                            if (currDist < selectedDistanceBaseThreat && target.isBaseThreat(gameState.map)) {
                                selectedDistanceBaseThreat = currDist;
                                selectedMonsterBaseThreat = target;
                                selectedInterceptionPointBaseThreat = interceptionPoint;
                            }
                        }

                    }
                    if (selectedMonsterBaseThreat != null) {
                        currentHero.target = selectedMonsterBaseThreat;
                        currentHero.targetPoint = selectedInterceptionPointBaseThreat;
                        selectedMonsterBaseThreat.isTargeted = true;
                    } else if (selectedMonster != null) {
                        currentHero.target = selectedMonster;
                        currentHero.targetPoint = selectedInterceptionPoint;
                        selectedMonster.isTargeted = true;
                    }
                }
                // Write an action using System.out.println()
                // To debug: System.err.println("Debug messages...");
                if (currentHero.target == null ) {
                    if (currentHero.patrolPoint == null || Utils.distance(currentHero.entity.getPosition(), gameState.map.patrolPoint1) < 1600) {
                        currentHero.patrolPoint = gameState.map.patrolPoint2;
                    } else if (Utils.distance(currentHero.entity.getPosition(), gameState.map.patrolPoint2) < 1600) {
                        currentHero.patrolPoint = gameState.map.patrolPoint1;
                    }
                    currentHero.targetPoint = currentHero.patrolPoint;
                }

                // In the first league: MOVE <x> <y> | WAIT; In later leagues: | SPELL <spellParams>;
                if (currentHero.target != null ) {
                    System.out.println("MOVE " + (int) currentHero.targetPoint.x + " " + (int) currentHero.targetPoint.y + " ATK");
                } else if (currentHero.patrolPoint != null) {
                    System.out.println("MOVE " + (int) currentHero.targetPoint.x + " " + (int) currentHero.targetPoint.y + " PAT");
                } else {
                    System.out.println("WAIT");
                }
            }
            
            long end = System.currentTimeMillis();
            System.err.println(end-start);
        }
    }


}

interface Strategy {

}

class Point2D {
    public double x;
    public double y;

    public Point2D(double x, double y) {
        this.x = x;
        this.y = y;
    }

    public double getX() {
        return x;
    }
    public double getY() {
        return y;
    }

    @Override
    public String toString() {
        return "Point[x=" + x +" ,y=" + y +"]";
    }
}


class Utils {

    public static Double fastSqrt(int d) {
        return Double.longBitsToDouble( ( ( Double.doubleToLongBits( Double.valueOf(d) )-(1l<<52) )>>1 ) + ( 1l<<61 ) );
    }

    public static Double fastSqrt(double d) {
        return Double.longBitsToDouble( ( ( Double.doubleToLongBits( d )-(1l<<52) )>>1 ) + ( 1l<<61 ) );
    }

    
    public static int sqpow(int val) {
        return val * val;
    }

    public static double sqpow(double val) {
        return val * val;
    }


    public static Double distance(Entity entity1, Entity entity2) {
        return Utils.fastSqrt(sqpow(entity2.x - entity1.x) + sqpow(entity2.y - entity1.y));
    }

    public static Double distance(Point2D entity1, Point2D entity2) {
        return Utils.fastSqrt(sqpow(entity2.x - entity1.x) + sqpow(entity2.y - entity1.y));
    }

    public static Point2D calculateInterceptionPoint(Entity hero, Entity monster) {
        return calculateInterceptionPoint(monster.getPosition(), monster.getSpeedVector(), hero.getPosition(), hero.getSpeed());
    }

    public static Point2D calculateInterceptionPoint(final Point2D a, final Point2D v, final Point2D b, final double s) {
		final double ox = a.getX() - b.getX();
		final double oy = a.getY() - b.getY();
 
		final double h1 = v.getX() * v.getX() + v.getY() * v.getY() - s * s;
		final double h2 = ox * v.getX() + oy * v.getY();
		double t;
		if (h1 == 0) { // problem collapses into a simple linear equation 
			t = -(ox * ox + oy * oy) / (2*h2);
		} else { // solve the quadratic equation
			final double minusPHalf = -h2 / h1;
 
			final double discriminant = minusPHalf * minusPHalf - (ox * ox + oy * oy) / h1; // term in brackets is h3
			if (discriminant < 0) { // no (real) solution then...
				return null;
			}
 
			final double root = Math.sqrt(discriminant);
 
			final double t1 = minusPHalf + root;
			final double t2 = minusPHalf - root;
 
			final double tMin = Math.min(t1, t2);
			final double tMax = Math.max(t1, t2);
 
			t = tMin > 0 ? tMin : tMax; // get the smaller of the two times, unless it's negative
			if (t < 0) { // we don't want a solution in the past
				return null;
			}
		}
 
		// calculate the point of interception using the found intercept time and return it
		return new Point2D(a.getX() + t * v.getX(), a.getY() + t * v.getY());
	}

}
